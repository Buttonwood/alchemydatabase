#labels Featured
= ALCHEMY DATABASE COMMANDS =

Alchemy Database supports:
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#Supported_SQL An OLTP optimised subset of SQL]
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#LUA_Command embedded LUA w/ client-server functionality]
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#REDIS_Commands ALL redis 2.0 commands]<br/>

==NOTES==
Supported SQL data types are currently UNSIGNED INT, UNSIGNED LONG, TEXT, and FLOAT.<br/>
Datetime should be represented as a UNSIGNED INT or FLOAT<br/>
TEXT uses variable length storage and compression and can be substituted for any VARCHAR() or CHAR().<br/>
UNSIGNED INT stores data using 2 bytes when possible.


==Supported SQL==

===Create/Drop Operations:===
  * {{{CREATE TABLE customer (id INT, group_id INT, name TEXT, phone text, age INT);}}}
  * {{{CREATE INDEX cust_group_ind ON customer (group_id);}}}
  * {{{DROP TABLE customer}}}
  * {{{DROP INDEX cust_group_ind}}}
  * {{{DESC customer}}} - provides detailed memory usage info
  * {{{DUMP customer}}} - dumps the table to client
  * {{{DUMP customer TO MYSQL}}} - dumps the table in mysql format
  * {{{DUMP customer TO FILE fname}}} - dumps the table to the file "fname"

===Single Row Operations===
  * {{{INSERT INTO customer VALUES (1,300,’John Doe’,’301-933-1891’,30);}}}
  * {{{SELECT group_id, phone FROM customer WHERE id = 1}}}
  * {{{DELETE FROM customer WHERE id = 1}}}
  * {{{UPDATE customer SET phone = ‘703-933-1891’, group_id = 4 WHERE id = 1}}}
  * {{{INSERT INTO customer VALUES (1,300,’John Doe’,’301-933-1891’,30) RETURN SIZE;}}} - returns the size of the row, table, and indices

===Index Operations===
  * {{{SELECT group_id, phone FROM customer WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{SELECT group_id, phone FROM customer WHERE group_id IN (300, 301, 307, 311) [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{DELETE FROM customer WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{UPDATE customer SET phone = ‘703-933-1891’, group_id = 4 WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}

===Update Expressions===
  UPDATE expressions currently support the following functionalities {{{(+=, -=, *=, /=, %=, ^=, ||=)}}}
{{{
UPDATE customer SET phone = phone || ' ext 912', group_id = group_id * 4, age = age + 1 WHERE id = 1
}}}

===Where Clause Grammar===
  The First column in the Where Clause determines the Index to use, subsequent columns will "filter" the rows matching the Index Lookup
{{{
WHERE {[pk/fk=X],[pk/fk BETWEEN X AND Y],[pk/fk IN (X,Y,Z)]} {AND [column=X],[column!=X],[column<X],[column<=X],[column>X],[column>=X],[column IN (X,Y,Z)]}*
}}}
  ORDER BY single and multiple columns with LIMIT OFFSET
{{{
WHERE fk = 7 ORDER BY col1 DESC, col2, col3 ASC LIMIT 10 OFFSET 100
}}}

===JOINS===
Alchemy currently supports denormalised Table Joins, and will soon support Star Schema joins<br/>
===Join via single Index===
{{{
SELECT customer.name, group.slogan
 FROM customer, group
 WHERE customer.group_id = group.id AND
       group.id BETWEEN 300 AND = 400
       [ORDER BY table.column LIMIT n OFFSET m]
}}}

===Create table from Join===
{{{
CREATE TABLE new_table
AS SELECT customer.name, group.slogan
FROM customer, group
WHERE customer.group_id = group.id AND
      group.id IN (300, 301, 307, 311)
}}}

===Full Table Scan===
Find unindexed data – _not recommended, should be avoided when possible_
{{{
SCANSELECT id, phone FROM customer WHERE name = ‘bill’ AND age BETWEEN 18 AND 25
}}}
  _the SCANSELECT command makes it impossible to accidentally do a full table scan w/ SELECT_

===Alchemy Cursors===
Since Alchemy is a *single threaded datastore*, long running queries block other queries during their execution.<br/>
For this reason Alchemy has cursors, similar (but simpler) to SQL cursors.<br/>
Alchemy Cursors use the construct _"ORDER BY pk/fk LIMIT X OFFSET *variable*"_ to store cursor state in _*variable*_ between cursor calls.<br/>
<br/>
An example of a long-running-update could be 
{{{
UPDATE tbl SET col=X WHERE fk = 1
}}}
which can be simply transformed into a cursor w/ client side logic (written in pseudocode):
{{{
ret=1000
while (ret == 1000) {
  ret = UPDATE tbl SET col=X WHERE fk = 1 ORDER BY fk LIMIT 1000 OFFSET CursorUpd8tbl
  sleep(0.01);
}
}}}
which will update the variable {{{CursorUpd8tbl}}} on each call (0->1000->2000->3000->...) and will erase the variable {{{CursorUpd8tbl}}} when the final row has been updated.<br/>
So calling the above command repeatedly, until the return value is less than _1000_ (which signals the final row matching _fk = 1_ has been updated) will complete the long-running-update described above, but in non-blocking chunks of 1000 rows (w/ 1ms sleeps between chunks).
<br/>
<br/>

==LUA Command==
Alchemy Database has embedded [http://www.lua.org/about.html LUA] <br/>
[http://www.ibm.com/developerworks/linux/library/l-embed-lua/index.html IBM's lua description]: _The Lua programming language is a small scripting language specifically designed to be embedded in other programs. Lua’s C API allows exceptionally clean and simple code both to call Lua from C, and to call C from Lua”_<br/>
Alchemy Database has embedded Lua in its C-server and C in its embedded Lua :)<br/>
The speed of embedded LUA commands in Alchemy Database is impressive: [http://groups.google.com/group/redisql-dev/msg/e24027e82e5c2094 benchmark] - TODO UPDATE<br/>

===embedded LUA "redis()" function===
The lua function "redis()" will call the Alchemy Database server internally as if it were a client call.<br/>
Function to set a user's last_login and return his status
{{{
 function getset_last_login
   redis('SET', 'user:123:last_login', 1289597410);
    return redis('GET', 'user:123:status');"
  end
}}}
===alchemy.lua===
The file [https://github.com/JakSprats/Alchemy-Database/blob/master/redis_unstable/tests/lua/alchemy.lua alchemy.lua] contains simplified Alchemy SQL calls<br/>
Loading alchemy.lua into the Alchemy Database server can be done either by specifiying the "luafilename" in the config file "redis.conf" or by the following command
{{{
./alchemy-cli CONFIG SET luafilename test/alchemy.lua
}}}
The "CONFIG SET luafilename" also provides a simple way to modify lua functions in Alchemy Database w/o server restarts. Modify the commands in alchemy.lua and then load them, this will *reset Lua's state* and the new functions will be in place.<br/>
To *ADD* lua functions to AlchemyDB (at runtime)
{{{
./alchemy-cli CONFIG ADD lua helper.lua
}}}
===calling LUA functions===
once a lua function has been imported into Alchemy, it is simple to call it. <br/>
Given the imported lua function 
{{{
  function getuserdata(arg1, arg2, arg3)
    ...
    return redis('GET', arg3');
  end
}}}
The Alchemy Database call will define the function name and its 3 arguments
{{{
   LUA getuserdata 'session_777' 'user_123' 'last_login'
}}}
and the data returned in the function _getuserdata_ will be output in redis' protocol (to be read by the client)

=TODO=
==LUA TRIGGERS==
==LRU==

==REDIS Commands==
redis supports commands to deal with many data structures, including (strings, sets, lists, sorted-sets, and hash tables)<br/>
redis' project home page *[http://redis.io/ here]*<br/>
Extensive documentation on redis commands can be found [http://redis.io/commands]<br/>
<br/>
The following is an IFRAME of redis' command reference page, complete w/ links describing each command<br/>
<wiki:gadget url="http://www.allinram.info/alsosql/gadget2.xml"  border="0" width="1200" height="2900"/> 