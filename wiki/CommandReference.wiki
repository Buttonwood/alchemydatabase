#labels Featured
= ALCHEMY DATABASE COMMANDS =

Alchemy Database supports:
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#Supported_SQL An OLTP optimised subset of SQL]
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#MORPH_Commands Commands to transform NOSQL data to SQL and vice versa (dubbed MORPH Commands)]
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#LUA_Command embedded LUA w/ client-server functionality]
  # [http://code.google.com/p/alchemydatabase/wiki/CommandReference#REDIS_Commands ALL redis 2.0 commands]<br/>

==NOTES==
Supported SQL data types are currently UNSIGNED INT, TEXT, and FLOAT.<br/>
Datetime should be represented as a UNSIGNED INT or FLOAT<br/>
TEXT uses variable length storage and compression and can be substituted for any VARCHAR() or CHAR().<br/>
UNSIGNED INT stores data using 2 bytes when possible.


==Supported SQL==

===Create/Drop Operations:===
  * {{{CREATE TABLE customer (id INT, group_id INT, name TEXT, phone text, age INT);}}}
  * {{{CREATE INDEX cust_group_ind ON customer (group_id);}}}
  * {{{DROP TABLE customer}}}
  * {{{DROP INDEX cust_group_ind}}}
  * {{{DESC customer}}} - provides detailed memory usage info
  * {{{DUMP customer}}} - dumps the table to client
  * {{{DUMP customer TO MYSQL}}} - dumps the table in mysql format
  * {{{DUMP customer TO FILE fname}}} - dumps the table to the file "fname"

===Single Row Operations===
  * {{{INSERT INTO customer VALUES (1,300,’John Doe’,’301-933-1891’,30);}}}
  * {{{SELECT group_id, phone FROM customer WHERE id = 1}}}
  * {{{DELETE FROM customer WHERE id = 1}}}
  * {{{UPDATE customer SET phone = ‘703-933-1891’, group_id = 4 WHERE id = 1}}}
  * {{{INSERT INTO customer VALUES (1,300,’John Doe’,’301-933-1891’,30) RETURN SIZE;}}} - returns the size of the row, table, and indices

===Index Operations===
  * {{{SELECT group_id, phone FROM customer WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{SELECT group_id, phone FROM customer WHERE group_id IN (300, 301, 307, 311) [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{DELETE FROM customer WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}
  * {{{UPDATE customer SET phone = ‘703-933-1891’, group_id = 4 WHERE group_id BETWEEN 300 AND 400 [ORDER BY column LIMIT n OFFSET m]}}}
  * _Introducing_ the *Non-Relational Range Query* - the IN() can contain ANY redis command that returns rows (e.g. LRANGE, SINTER, ZREVRANGE, etc...)
  Get name and number of the 5 most recent active customers
{{{
SELECT name, phone FROM customer WHERE group_id IN ($LRANGE L_IND_recent_calls 0 5) [ORDER BY column LIMIT n OFFSET m]
}}}

===Update Expressions===
  UPDATE expressions currently support the following functionalities {{{(+=, -=, *=, /=, %=, ^=, ||=)}}}
{{{
UPDATE customer SET phone = phone || ' ext 912', group_id = group_id * 4, age = age + 1 WHERE id = 1
}}}

===Where Clause Grammar===
  The First column in the Where Clause determines the Index to use, subsequent columns will "filter" the rows matching the Index Lookup
{{{
WHERE {[pk/fk=X],[pk/fk BETWEEN X AND Y],[pk/fk IN (X,Y,Z)]} {AND [column=X],[column!=X],[column<X],[column<=X],[column>X],[column>=X],[column IN (X,Y,Z)]}*
}}}
  ORDER BY single and multiple columns with LIMIT OFFSET
{{{
WHERE fk = 7 ORDER BY col1 DESC, col2, col3 ASC LIMIT 10 OFFSET 100
}}}

===JOINS===
Alchemy currently supports denormalised Table Joins, and will soon support Star Schema joins<br/>
===Join via single Index===
{{{
SELECT customer.name, group.slogan
 FROM customer, group
 WHERE customer.group_id = group.id AND
       group.id BETWEEN 300 AND = 400
       [ORDER BY table.column LIMIT n OFFSET m]
}}}

===Multi Index Join w/ Non-Relational IN() Clause===
Get patient billing info for patients who got both treatment and prescriptions
{{{
SELECT patient.name, info.address, bill.amount
FROM patient, info, bill
WHERE patient.id = bill.patient_id AND
      patient.id = info.patient_id AND
      patient.id IN ($SINTER treatment_set prescription_set)
      [ORDER BY table.column LIMIT n OFFSET m]
}}}

===Create table from Join===
{{{
CREATE TABLE new_table
AS SELECT customer.name, group.slogan
FROM customer, group
WHERE customer.group_id = group.id AND
      group.id IN (300, 301, 307, 311)
}}}

===Full Table Scan===
Find unindexed data – _not recommended, should be avoided when possible_
{{{
SCANSELECT id, phone FROM customer WHERE name = ‘bill’ AND age BETWEEN 18 AND 25
}}}
  _the SCANSELECT command makes it impossible to accidentally do a full table scan w/ SELECT_

===Alchemy Cursors===
Since Alchemy is a *single threaded datastore*, long running queries block other queries during their execution.<br/>
For this reason Alchemy has cursors, similar (but simpler) to SQL cursors.<br/>
Alchemy Cursors use the construct _"ORDER BY pk/fk LIMIT X OFFSET *variable*"_ to store cursor state in _*variable*_ between cursor calls.<br/>
<br/>
An example of a long-running-update could be 
{{{
UPDATE tbl SET col=X WHERE fk = 1
}}}
which can be simply transformed into a cursor w/ client side logic (written in pseudocode):
{{{
ret=1000
while (ret == 1000) {
  ret = UPDATE tbl SET col=X WHERE fk = 1 ORDER BY fk LIMIT 1000 OFFSET CursorUpd8tbl
  sleep(0.01);
}
}}}
which will update the variable {{{CursorUpd8tbl}}} on each call (0->1000->2000->3000->...) and will erase the variable {{{CursorUpd8tbl}}} when the final row has been updated.<br/>
So calling the above command repeatedly, until the return value is less than _1000_ (which signals the final row matching _fk = 1_ has been updated) will complete the long-running-update described above, but in non-blocking chunks of 1000 rows (w/ 1ms sleeps between chunks).
<br/>
<br/>
==MORPH Commands==
===Store the results of an Alsoql SELECT into a redis datastructure===
  * SELECT ..... STORE REDIS_COMMAND
{{{
SELECT name, salary
FROM employee
WHERE city = "san Francisco"
STORE HSET SanFranWorker
}}}
      # create a redis Hash Table named {{{SanFranWorker}}} with all the employees from city "San Francisco"
      # the values returned from the SELECTed column "name" will be the Hash Table's keys
      # the values returned from the SELECTed column "salary" will be the Hash Table's values

  * DENORMALISED SELECT STORE:
  In the following command, the "_$_" on the end of "_user_action_zset$_" means the results of the SELECT will be prepended to the REDIS_COMMAND with no spaces between
{{{
SELECT user_id, timestamp, action
FROM actionlist
WHERE id BETWEEN 1 AND 20000
STORE ZADD user_act_zset_$
}}}
    # for each _user_id_, a unique ZSET will be created named ("user_act_zset_1","user_act_zset_2","user_act_zset_3"), etc...
    # each row will execute the command "_`ZADD user_act_zset_${user_id} timestamp action`_"
    # afterwards the command "_`ZREVRANGE user_act_zset_1 0 1`_" would return user 1's most recent two actions
    # this functionality is demonstrated in this [http://github.com/JakSprats/redis-rb/blob/master/examples/action_list.rb Ruby script]

===Create a Alchemy Database table from the results of a redis command===
  * CREATE TABLE table AS REDIS_COMMAND
  NOTE: the ZSET tweets uses timestamp as its score
{{{
CREATE TABLE yesterdays_tweets AS ZRANGEBYSCORE tweets $two_days_ago $yesterday
}}}
      # take the members of the ZSET from two_days_ago until yesterday
      # store them in a Alchemy Database table named "yesterdays_tweets" (pk will be auto incremented INT)
      # an example in PHP can be found in the example script [http://github.com/JakSprats/predis/blob/master/examples/tweet/tweet_archiver.php here] that calls the ZSetCache class [http://github.com/JakSprats/predis/blob/master/examples/ZsetCache.php here]

===Denormalise a Alchemy Database table into one redis hash-table per table row===
  * DENORM table denorm_wildcard
{{{
DENORM user "user:*"
}}}
      # denormalise the "user" table into an individual hash-table per row, named "user:pk" (e.g. user:1, user:2)
      # the keys of these hashes will be the column-names of the "user" table.
  this is a simple mechanism to "Go Schemaless", an example script in PHP showcasing this can be found [http://github.com/JakSprats/predis/blob/master/examples/schemaless.php here]

<br/>
==LUA Command==
Alchemy Database has embedded [http://www.lua.org/about.html LUA] <br/>
[http://www.ibm.com/developerworks/linux/library/l-embed-lua/index.html IBM's lua description]: _The Lua programming language is a small scripting language specifically designed to be embedded in other programs. Lua’s C API allows exceptionally clean and simple code both to call Lua from C, and to call C from Lua”_<br/>
Alchemy Database has embedded Lua in its C-server and C in its embedded Lua :)<br/>
The speed of embedded LUA commands in Alchemy Database is impressive: [http://groups.google.com/group/redisql-dev/msg/e24027e82e5c2094 benchmark]<br/>

===Simple LUA===
{{{
LUA "x=45;return x;"
}}}
===embedded LUA "client()" function===
The lua function "client()" will call the Alchemy Database server internally as if it were a client call.<br/>
Command to set a user's last_login and return his status
{{{
LUA "client('SET','user:123:last_login',1289597410); return client('GET', 'user:123:status');"
}}}
===alchemy.lua===
The file [https://github.com/JakSprats/Redisql/blob/master/test/alchemy.lua alchemy.lua] contains a full Alchemy Database client library, defining simple versions of Alchemy Database commands: e.g. get(), set(), zadd(), hset(), create_table(), select(), update(), norm()<br/>
When alchemy.lua's functions have been loaded into Alchemy Database, the above command could be simplified as 
{{{
LUA "set('user:123:last_login',1289597410); return get('user:123:status');"
}}}
Loading alchmey.lua into the Alchemy Database server can be done either by specifiying the "luafilename" in the config file "redisql.conf" or by the following command
{{{
./redisql-cli CONFIG SET luafilename test/alchemy.lua
}}}
The "CONFIG SET luafilename" also provides a simple way to modify lua functions in Alchemy Database w/o server restarts. Modify the commands in alchemy.lua and then load them, this will *reset Lua's state* and the new functions will be in place.<br/>
To *ADD* lua functions to AlchemyDB (at runtime)
{{{
./redisql-cli CONFIG ADD lua helper.lua
}}}
===Global Lua Variable Server===
This form of embedding Lua extends Alchemy Database to be a global lua variable server. Lua variables have global scope, so if one client sets them another can read them.<br/>
[http://lua-users.org/wiki/TablesTutorial Lua tables] are a very flexible and useful datatype in Lua<br/>
Here is a command sequence from different clients accessing the same Lua table:
{{{
LUA "user_123_t = { 1,1,2,3,5,8,13 }; return 'SET lua table';"
LUA "return user_123_t[4];"
}}}
NOTE: for those requiring enhanced Lua performance, Alchemy Database's [https://github.com/JakSprats/Redisql/blob/master/Makefile#L14-23 Makefile] has an option (and instructions) to link to libluajit instead of liblua.
<br/>
<br/>
=== SQL + NOSQL and the Non-Relational-Index ===
The following example will show how some problems dont quite fit into SQL, and dont quite fit into NOSQL, but the combination of SQL+NOSQL fits them perfectly, and then Lua is thrown in as a stored-procedure-like optimisation.
<br/>
  SETUP: the 2nd index is a Non-Relational-Index (similar to a SQL trigger), which per INSERT
    # forms a redis command by performing character substitution on the index-string using the values of the columns of the inserted row
    # runs the redis command
{{{
CREATE TABLE messages AS (id INT, member_id INT, timestamp INT, message TEXT)
CREATE INDEX ind_msg_mem ON messages (member_id)
CREATE INDEX ind_msg_ts  ON messages "LPUSH msg_ts_$member_id $id"
}}}
        Inserting "_`(1,33,1294761320,'hows the weather today?')`_" would run "_`LPUSH msg_ts_33 1`_"

  Inserting messages and capping per member messages to 100 (written in pseudocode)
    # first check the number of messages member _33_ has
    # if it is more than _100_, remove the final message from both the Non-Relational-Index and the Table (using a Non-Relational-Delete)
    # Insert the row "_`(1,33,1294761320,'hows the weather today?')`_"
{{{
    len = LLEN(msg_ts_33);
    if (len > 100) {
        DELETE FROM message WHERE id IN ($RPOP msg_ts_33);
    }
    INSERT INTO messages VALUES (1,33,1294761320,'hows the weather today?');
}}}
  Get last 5 message for member 33
{{{
    SELECT message FROM messages WHERE id IN ($LRANGE msg_ts_33 0 4)
}}}
  The Insert-cap step can be turned into the following lua function
{{{
function insert_msg_cap(member_id, row, limit)
    len = llen('msg_ts_' .. member_id);
    if (len > 100) then
        delete('messages','id IN ($RPOP msg_ts_' .. member_id .. ')';
    end
    return insert('messages', row);
end
}}}
  And then called via:
{{{
    LUA "return insert_msg_cap(33, '1,33,1294761320,\'hows the weather today?\'', 100);"
}}}
  The final product:
    # requires NO sorting
    # performs all lookups via Primary-Key
    # implicitly stores the timestamp index in natural order (saves memory over a sorted relational index)
    # uses LUA to create a stored procedure (less network I/O)
<br/>
==REDIS Commands==
redis supports commands to deal with many data structures, including (strings, sets, lists, sorted-sets, and hash tables)<br/>
redis' project home page *[http://redis.io/ here]*<br/>
Extensive documentation on redis commands can be found [http://redis.io/commands]<br/>
<br/>
The following is an IFRAME of redis' command reference page, complete w/ links describing each command<br/>
<wiki:gadget url="http://www.allinram.info/alsosql/gadget2.xml"  border="0" width="1200" height="2900"/> 

===SQL NOTES===
  # Column ordering in INSERT statements not yet supported
  # Table aliasing in JOIN statements not yet supported
  # Multiple Column ORDER BYs not yet supported for JOINS