=Lua Object Column Type=

Alchemy Database has a column type called "LUAOBJ" which contains a [http://lua-users.org/wiki/TablesTutorial Lua table]. [http://www.lua.org/about.html Lua] is a turing complete  embedded language, and Lua tables can be efficiently used to store almost any data structure (even ones w/ functions, aka objects :)

Alchemy Database combines the relational logic of a RDBMS w/ the power of Lua tables and functions and the resulting data-store resembles both an Object-Database and a Document-Store.

To create a LuaObject Column, declare the column as type LUAOBJ:
{{{
   CREATE TABLE users (userid INT, zipcode INT, info LUAOBJ)
}}}

Inserting data into a LuaObject column is done as a Lua table construction (e.g. `tbl={...}`)
{{{
  INSERT INTO users (userid, zipcode, info) VALUES (1,44555,{fname='BILL',lname='DOE',age=32,groupid=999,height=70,weight=180})
  INSERT INTO users (userid, zipcode, info) VALUES (2,44555,{fname='Jane',lname='Smith',age=22,groupid=888,coupon='XYZ123'})
}}}
Note: in the 2nd INSERT `info.height & info.weight` are not defined, which is ok, as the lua-object has no defined structure.

Elements within a LuaObject can be indexed, w/ Dot-Notation-Indexing (NOTE: the final argument specifies a data type for the index)
{{{
  CREATE INDEX i_users_i_a ON users (info.age) LONG
  CREATE INDEX i_users_i_g ON users (info.groupid) LONG
}}}

The following queries would use the previous indexes and return ['BILL' & 'Jane'] respectively
{{{
  SELECT info.name FROM users WHERE info.age = 32
  SELECT info.name FROM users WHERE info.groupid = 888
}}}
In the author's humble opinion, Dot-Notation-Indexes should be viewed as slightly inferior when compared to normal indexes. It is recommended practice, that if you use a Dot-Notation-Index heavily, to break it out into a normal SQL index, which perform slightly better as the overhead of passing data between C & Lua is avoided and Dot-Notation-Indexes currently have limitations (no ORDER BY DNIs or JOINs on DNIs).

The described functionality already yields a basic Document-Store or Object-Database, and technically more as Lua supports arbitrary nesting of tables and Lua has scores of libraries already written and tested (some in production going on 20 years). Since Lua is so powerful,flexible,efficient, & natural-to-embed, it made sense to integrate Lua as deeply as possible into SQL, to achieve a variant of SQL that has the benefits of a full programming language.

This integration is best described w/ some examples, as it is a syntactic mixing of SQL, Lua Tables, and Lua functions.

First define a Lua function in AlchemyDB: a string of Lua can be passed to Alchemy, which is then interpreted (and remains defined in the Lua universe for later use)
{{{
   INTERPRET_LUA "function has_coupon(info, code) if (info.coupon ~= nil and info.coupon == code) then return 1; else return 0; end; end"
}}}
Note: this function sees if a particular luaobject column has the field "coupon_code" defined, and then checks to see if it matches the coupon_code from the function call.

The following query now becomes possible
{{{
  CREATE INDEX i_u_zip ON users (zipcode)
  SELECT info.name FROM users WHERE zipcode = 44555 AND has_coupon(info, 'XYZ123')
}}}
The function "has_coupon()" will be run on every row w/ zipcode 44555, and ONLY those rows having "info.coupon_code='XYZ123'" will be returned.

Besides adding Lua functionality in the where-clause, it is also possible to call Lua from:
  * SELECT Column Clause
{{{
    INTERPRET_LUA "function format_name(t) return string.sub(t.fname, 1, 1) .. '. ' .. t.lname; end"
    SELECT format_name(info) FROM users WHERE zipcode = 44555 AND has_coupon(info, 'XYZ123')
}}}
  * UPDATE Set Clause
{{{
   INTERPRET_LUA "function generate_coupon() return 'XYZ' .. math.random(1,999); end"
   UPDATE users SET info.coupon = generate_coupon() WHERE userid = 1
}}}
  * Complex UPDATEs via SELECTs
{{{
    INTERPRET_LUA "weight_gain_per_year={}; weight_gain_per_year[20]=1; weight_gain_per_year[25]=2; weight_gain_per_year[30]=3; weight_gain_per_year[35]=4; weight_gain_per_year[40]=5; weight_gain_per_year[45]=5; weight_gain_per_year[50]=4; weight_gain_per_year[55]=3; weight_gain_per_year[60]=2;"
    INTERPRET_LUA "function update_weight(info) for k, v in pairs(weight_gain_per_year) do if (k > info.age) then info.weight = info.weight + v; return true; end; end; return false; end"
    SELECT update_weight(info) FROM users WHERE userid = 1
}}}
  * ORDER BY Clause
{{{
    SELECT format_name(info) FROM users WHERE zipcode = 44555 ORDER BY string.sub(info.lname,1,3)
}}}

These examples are pretty lame, but hopefully it is clear that combining Lua & SQL in such a way provides a highly flexible DML (implemented highly efficiently using Lua's virtual stack) that logically fits within the relational model. The goal here is to be able to do the exact operations you want to do on your data as efficiently as possible and not have to tweak & bend them to fit into SQL.

== Lua Internals ==
===Direct Lua Access to Lua-Objects===
AlchemyDB stores each LuaObject column in Lua's universe. Each row's LuaObject Column is stored as a Lua Table that is addressable as `ASQL[tblname][columnname][pk]`. If we took the above example, where the table "users" has the LuaObject "info", and userid=1, the LuaObject is stored in a table at `ASQL["users"]["info"][1]`. Manipulating the LUAOBJ table's values directly in Lua is OK (e.g. setting `ASQL["users"]["info"][1].newfield=7` is OK)  and will not corrupt the database, but do not modify any data in the `ASQL[tblname][columnname][pk]` tree as this tree represents the raw database (e.g. do NOT do: `ASQL["users"]["info"]=nil`, as this deletes ALL `users.info` LUAOBJ's).

===Direct Lua Access to Dot-Notation-Indexed Elements===
AlchemyDB did some Lua voodoo (combo of __index & __newindex meta-method trickery) to ensure that if a Dot-Notation-Indexed value is changed directly in Lua, the change will be reflected in Alchemy's indexes. This can be reworded as: changing the value of a Dot-Notation-Indexed field directly in Lua will cause an update-index-trigger in Alchemy. An example of this would be (setting `ASQL["users"]["info"][1].age=55` would cause an update-trigger to the "i_users_i_a" index, and a subsequent SQL query: `SELECT * FROM users WHERE info.age=55` would return the row w/ userid=1)

This ensures data consistency between Lua & the RDBMS and means the developer does not have to worry about where he changes data, his changes will be reflected in both Lua & via SQL.