=Lua Object Column Type=

Alchemy Database has a column type called "LUAOBJ" which contains a [http://lua-users.org/wiki/TablesTutorial lua table]. [http://www.lua.org/about.html Lua] is a turing complete  embedded language, and lua tables can hold pretty much any type of data (including functions).

Alchemy Database combines the relational logic of a RDBMS w/ the power of Lua tables and functions and the resulting data-store resembles both an Object-Database and a Document-Store.

To create a LuaObject Column, declare the column as type LUAOBJ:
{{{
   CREATE TABLE users (userid INT, zipcode INT, info LUAOBJ)
}}}

Inserting data into a LuaObject column is done as a lua table construction (e.g. `tbl={...}`)
{{{
  INSERT INTO users (userid, zipcode, info) VALUES (1,44555,{fname='BILL',lname='DOE',age=32,groupid=999,height=70,weight=180})
  INSERT INTO users (userid, zipcode, info) VALUES (2,44555,{fname='Jane',lname='Smith',age=22,groupid=888,coupon='XYZ123'})
}}}
Note: in the 2nd INSERT `info.height & info.weight` are not defined, which is ok, as the lua-object has no defined structure.

Elements within a LuaObject can be indexed, w/ Dot-Notation-Indexing
{{{
  CREATE INDEX i_users_i_a ON users (info.age) LONG
  CREATE INDEX i_users_i_g ON users (info.groupid) LONG
}}}

The following queries would use the previous indexes and return ['BILL' & 'Jane'] respectively
{{{
  SELECT info.name FROM users WHERE info.age = 32
  SELECT info.name FROM users WHERE info.groupid = 888
}}}
In the author's humble opinion, Dot-Notation-Indexes should be viewed as slightly inferior when compared to normal indexes. It is recommended practice, that if you use a Dot-Notation-Index heavily, to break it out into a normal SQL index, which perform slightly better as the overhead of passing data between C & Lua is avoided and Dot-Notation-Indexes currently have limitations (no ORDER BY DNIs or JOINs on DNIs).

The described functionality already yields a basic Document-Store or Object-Database, and technically more as Lua supports arbitrary nesting of tables and Lua has scores of libraries already written and tested in production for up to 20 years. Since Lua provides so much, AlchemyDB made the choice to integrate Lua all the way into SQL.

This integration is best described w/ some examples, as it is a syntactic mixing of SQL, Lua Tables, and Lua functions.

First define a lua function in AlchemyDB: a string of Lua can be passed to Alchemy, which is then interpreted (and remains defined in the Lua universe for later use)
{{{
   INTERPRET_LUA "function has_coupon(info, code) if (info.coupon ~= nil and info.coupon == code) then return 1; else return 0; end; end"
}}}
Note: this function sees if a particular luaobject column has the field "coupon_code" defined, and then checks to see if it matches the coupon_code from the function call.

The following query now becomes possible
{{{
  CREATE INDEX i_u_zip ON users (zipcode)
  SELECT info.name FROM users WHERE zipcode = 44555 AND has_coupon(info, 'XYZ123')
}}}
The function "has_coupon()" will be run on every row w/ zipcode 44555, and ONLY those rows having "info.coupon_code='XYZ123'" they will be returned.

Besides adding lua functionality in the where-clause, it is also possible to call lua from:
  * SELECT Column Clause
{{{
    INTERPRET_LUA "function format_name(t) return string.sub(t.fname, 1, 1) .. '. ' .. t.lname; end"
    SELECT format_name(info) FROM users WHERE zipcode = 44555 AND has_coupon(info, 'XYZ123')
}}}
  * UPDATE Set Clause
{{{
   INTERPRET_LUA "function generate_coupon() return 'XYZ' .. math.random(1,999); end"
   UPDATE users SET info.coupon = generate_coupon() WHERE userid = 1
}}}
  * Complex UPDATEs via SELECTs
{{{
    INTERPRET_LUA "weight_gain_per_year={}; weight_gain_per_year[20]=1; weight_gain_per_year[25]=2; weight_gain_per_year[30]=3; weight_gain_per_year[35]=4; weight_gain_per_year[40]=5; weight_gain_per_year[45]=5; weight_gain_per_year[50]=4; weight_gain_per_year[55]=3; weight_gain_per_year[60]=2;"
    INTERPRET_LUA "function update_weight(info) for k, v in pairs(weight_gain_per_year) do if (k > info.age) then info.weight = info.weight + v; return true; end; end; return false; end"
    SELECT "update_weight(info)" FROM users WHERE "userid = 1"
}}}
  * ORDER BY Clause
{{{
    SELECT sha1(info.name) FROM users WHERE zipcode = 44555 AND has_coupon(info, 'XYZ123') ORDER BY (info.height * info.weight) 
}}}
NOTE: in the previous examples: the functions (sha1 & compute_score_from_many_variables) need to be previously defined (normally via INTERPRETLUA)

These examples are pretty lame, but hopefully it is clear that combining Lua & SQL in such a way provides both a highly flexible DML & also a highly efficient Data-Store.