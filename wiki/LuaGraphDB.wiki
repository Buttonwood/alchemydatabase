= Alchemy's Graph Database =

A [http://en.wikipedia.org/wiki/Graph_database Graph Database] uses graph structures with nodes, edges, and properties to represent and store data. AlchemyDB modeled its Graph Database implementation after [http://neo4j.org/ Neo4j], the best of breed in GraphDBs.

The purpose of building a GraphDB into AlchemyDB was two fold: 
  # it is nice to be able to do graph traversals on your data, so "embedding" a GraphDB is a wonderful add-on,
  # it provides an example of how AlchemyDB's mix of Lua & SQL is simple-to-use, highly-flexible, very efficient, & can be used as a data-platform. 
A Data Platform is a data-store that is made to be extensible. Adding a GraphDB to AlchemyDB was done using AlchemyDB's existing tools.

== GraphDB Basics ==
A `Node` stores data. A `Node` can have `Relationships` to other Nodes. An example would be `James -> KNOWS -> Jill`. Here, "James" & "Jill" are the `Nodes` and `KNOWS` is the `Relationship`.

`Node`s can also have `Properties`, which are unstructured key-value data attached to the Node. `James` could have the `Property: ['job-title'='manager']`. 'Jill' could have the `Property: ['hobby'='swimming']`.

GraphDB's excel at queries like: _Find ALL the managers who know people whose hobby is swimming_. Doing this type of query in SQL is awkward, unnecessarily complicated, and easy to mess up.

A `Relationship` can also have a `Property` associated to it, for instance if James knows Jill since 2005, then the relationship would have the `Property:` ('since'=2005) and can be visually represented as `Relationship: James -> KNOWS (since:2005) -> Jill`

== Lua implementation ==
AlchemyDB implements a GraphDB using Lua for logic and SQL for indexing. GraphDB functionality is available both at the SQL level and at the Lua function level. GraphDB nodes are embedded into AlchemyDB's [http://code.google.com/p/alchemydatabase/wiki/LuaObject LuaObj] column type, which is how they achieve schemaless storage.

The core code for the GraphDB can be found [https://github.com/JakSprats/Alchemy-Database/blob/master/redis_unstable/src/core/graph.lua here].  Examples, showing depth-first traversals, breadth-first traversals, and shortest-path algorithms can be found [https://github.com/JakSprats/Alchemy-Database/blob/master/redis_unstable/src/core/example_user_cities.lua here].

== Examples==
Here is an example, that contains some cities and some fictional distances between them and finds the shortest route from Washington D.C. to San Francisco.

_NOTE: in this particular use-case it made sense to have all APIs in Lua & the Lua routines call SQL. The [http://code.google.com/p/alchemydatabase/wiki/CommandReference#LUATRIGGER LUATRIGGER] is used to create a `City-Name to PK lookup table` contained (and used) completely in Lua_

Definitions for the functions `addSqlCityRowAndNode(), addCityDistance(), & shortestPathByCityName()` can be found [https://github.com/JakSprats/Alchemy-Database/blob/master/redis_unstable/src/core/example_user_cities.lua#L64-87 here.]. They are all fairly simple routines that make the API simpler for the programmer, and are good examples of how server-side scripting can not only encapsulate funcitonality, but also avoid unnecessary App-Server to DB-Server calls.
{{{
  INTERPRET LUAFILE "core/graph.lua";
  INTERPRET LUAFILE "core/example_user_cities.lua";
  CREATE TABLE cities (pk INT, lo LUAOBJ, name TEXT)
  CREATE LUATRIGGER lt_cities ON cities INSERT add_city(name, pk)
  CREATE LUATRIGGER lt_cities ON cities DELETE del_city(name)
  LUAFUNC addSqlCityRowAndNode 10 'Washington D.C.' 'DC'
  LUAFUNC addSqlCityRowAndNode 20 'New York City' 'NYC'
  LUAFUNC addSqlCityRowAndNode 30 'San Francisco' 'SF'
  LUAFUNC addSqlCityRowAndNode 40 'Chicago' 'CHI'
  LUAFUNC addSqlCityRowAndNode 50 'Cheyenne' 'CHE'
  LUAFUNC addSqlCityRowAndNode 60 'Atlanta' 'ATL'
  LUAFUNC addSqlCityRowAndNode 70 'Dallas' 'DAL'
  LUAFUNC addSqlCityRowAndNode 80 'Albuquerque' 'ALB'
  LUAFUNC addSqlCityRowAndNode 90 'Lexington' 'LEX'
  LUAFUNC addSqlCityRowAndNode 100 'St. Louis' 'STL'
  LUAFUNC addSqlCityRowAndNode 110 'Kansas City' 'KC'
  LUAFUNC addSqlCityRowAndNode 120 'Denver' 'DEN'
  LUAFUNC addSqlCityRowAndNode 130 'Salt Lake City' 'SLC'

  LUAFUNC addCityDistance 'Washington D.C.' 'Chicago'        200
  LUAFUNC addCityDistance 'Chicago'         'San Francisco'  500 # = 700
  LUAFUNC addCityDistance 'Chicago'         'Cheyenne'       200
  LUAFUNC addCityDistance 'Cheyenne'        'San Francisco'  200 # = 600

  LUAFUNC addCityDistance 'Washington D.C.' 'Atlanta'        100
  LUAFUNC addCityDistance 'Atlanta'         'Dallas'         100
  LUAFUNC addCityDistance 'Dallas'          'San Francisco'  300 # = 500
  LUAFUNC addCityDistance 'Dallas'          'Albuquerque'    100
  LUAFUNC addCityDistance 'Albuquerque'     'San Francisco'  100 # = 400

  LUAFUNC addCityDistance 'Washington D.C.' 'Lexington'       50
  LUAFUNC addCityDistance 'Lexington'       'St. Louis'       50
  LUAFUNC addCityDistance 'St. Louis'       'Kansas City'     50
  LUAFUNC addCityDistance 'Kansas City'     'Denver'          50
  LUAFUNC addCityDistance 'Denver'          'Salt Lake City'  50
  LUAFUNC addCityDistance 'Salt Lake City'  'San Francisco'   50 # = 300

  LUAFUNC shortestPathByCityName 'cities' 'Washington D.C.' 'San Francisco' 'RELATIONSHIP_COST.WEIGHT'             
}}}

== Pure Lua Function Indexes ==
*TODO*: need an example code for these

Graph Databases often have the ability to index specific relationships. For instance, the relationship: `users who have visited NYC` can be indexed. And looking up users who have visited NYC is an efficient index lookup. Alchemy introduced a pure lua function index for this purpose. It is up to the developer to maintain this index in his lua routines. 

Using the example of indexing the relationship: `users who have visited NYC` the developer should add new primary keys to this index every time a user creates a relationship `VISITS->NYC`. Deleting this relationship doesnt really make much sense, but if a user could somehow UN-visit NYC, then his primary key should be deleted from this index. The explanation so far has been an oversimplification: every time a user visits a city (assuming users are in the SQL table: `users` and cities are in the SQL table: `cities`) the call: `alchemySetIndexByName('visits_index', cities.pk, user.pk)`. This allows later calls to get all users.PKs who have visited city w/ cities.PK=X possible.

Here is Alchemy's syntax for the Pure Lua Function Index:
{{{
   CREATE INDEX indexname ON tablename "(whereclausetoken())" TYPE constructUserGraphHooks destructUserGraphHooks
}}}
TYPE can be any column type: (e.g. INT,TEXT,FLOAT,etc..)

`whereclausetoken()` is used in SQL where clauses to directly access the Pure-Lua-Function-Index.

Examples:
{{{
  SELECT \* FROM tablename WHERE whereclausetoken() = 7
  SELECT \* FROM tablename WHERE whereclausetoken() BETWEEN 2 AND 5
  SELECT \* FROM tablename WHERE whereclausetoken() IN (3,7,9)
}}}

`constructUserGraphHooks` is a lua function that should place hooks into your Lua environment and "Construct" the Index.

`destructUserGraphHooks` is a lua function responsible for destructing the Index.

The Lua functions that the hooks can use to call into Alchemy's RDBMS are:
{{{
  alchemySetIndexByName(), alchemyUpdateIndexByName(), alchemyDeleteIndexByName()
}}}

== USERS EXAMPLE ==
This example has _"USERS"_ who _"KNOW"_ each other and who _"VIEWED_PIC"_ each other.
These _"USERS"_ can also _"HAS_VISITED"_ different _"CITIES"_.

Once the relationships have been defined, the following two graph traversals are done:
  # Friends-Of-Friends who have seen my picture (w/ Breadth-First-Search & Depth-First-Search
  # Friends-Of-Friends who have seen each other's picture AND seen my picture

These traversals demonstrate the GraphDB's API, which can be grouped into:
  * Breadth & Depth First Search Members:
    # EDGE_EVAL:
    # EXPANDER: 
    # ALL_RELATIONSHIP_EXPANDER:
    # UNIQUENESS.
    # MIN_DEPTH & MAX_DEPTH
  * Shortest Path Members:
    # NODE_DELTA:
    # RELATIONSHIP_COST:

At the end of the example, the query for _Users who have visited Washington D.C_ is made. The Indexing of Graph Relationships is accomplished via AlchemyDB's Pure Lua Function Index, which leaves the Index add/delete/updating to be done in Lua (in user defined routines), but allows the Index to be queries in SQL.

{{{
  CREATE TABLE users (pk INT, hometown INT, lo LUAOBJ)
  CREATE INDEX lf_users ON users (relindx()) LONG constructUserGraphHooks destructUserGraphHooks

  LUAFUNC addSqlUserRowAndNode 1 10 'A'
  LUAFUNC addSqlUserRowAndNode 2 10 'B'
  LUAFUNC addSqlUserRowAndNode 3 20 'C'
  LUAFUNC addSqlUserRowAndNode 4 20 'D'
  LUAFUNC addSqlUserRowAndNode 5 30 'E'
  LUAFUNC addSqlUserRowAndNode 6 30 'F'
  LUAFUNC addSqlUserRowAndNode 7 30 'G'

  LUAFUNC addNodeRelationShipByPK 'users' 1 "KNOWS" 'users' 2
  LUAFUNC addNodeRelationShipByPK 'users' 2 "KNOWS" 'users' 4
  LUAFUNC addNodeRelationShipByPK 'users' 4 "KNOWS" 'users' 7
  LUAFUNC addNodeRelationShipByPK 'users' 1 "KNOWS" 'users' 3
  LUAFUNC addNodeRelationShipByPK 'users' 3 "KNOWS" 'users' 5
  LUAFUNC addNodeRelationShipByPK 'users' 3 "KNOWS" 'users' 6

  LUAFUNC addNodeRelationShipByPK 'users' 1 "VIEWED_PIC" 'users' 2
  LUAFUNC addNodeRelationShipByPK 'users' 2 "VIEWED_PIC" 'users' 4
  LUAFUNC addNodeRelationShipByPK 'users' 4 "VIEWED_PIC" 'users' 1

  LUAFUNC addNodeRelationShipByPK 'users' 6 "VIEWED_PIC" 'users' 1
  LUAFUNC addNodeRelationShipByPK 'users' 5 "VIEWED_PIC" 'users' 7

  # 'BFS: FOF who have seen my picture'
  LUAFUNC traverseByPK BFS "users" 1 "REPLY.NODENAME_AND_PATH"
                                     "EXPANDER.FOF"
                                     "UNIQUENESS.PATH_GLOBAL"
                                     "EDGE_EVAL.FOF"

  # 'BFS: FriendsANDPictureSeen-OfFriends  who have seen my picture'
  LUAFUNC traverseByPK BFS "users" 1 "REPLY.NODENAME_AND_PATH"
                                     "ALL_RELATIONSHIP_EXPANDER.FOF"
                                     "UNIQUENESS.PATH_GLOBAL"
                                     "EDGE_EVAL.FOF"

  # 'DFS: FOF who have seen my picture'
  LUAFUNC traverseByPK DFS "users" 1 "REPLY.NODENAME_AND_PATH" 
                                     "EXPANDER.FOF"            
                                     "UNIQUENESS.PATH_GLOBAL"  
                                     "EDGE_EVAL.FOF"

  # WASHINGTON
  LUAFUNC addNodeRelationShipByPK 'users' 1 "HAS_VISITED" 'cities' 10
  LUAFUNC addNodeRelationShipByPK 'users' 4 "HAS_VISITED" 'cities' 10
  LUAFUNC addNodeRelationShipByPK 'users' 7 "HAS_VISITED" 'cities' 10

  # NYC
  LUAFUNC addNodeRelationShipByPK 'users' 1 "HAS_VISITED" 'cities' 20
  LUAFUNC addNodeRelationShipByPK 'users' 2 "HAS_VISITED" 'cities' 20
  LUAFUNC addNodeRelationShipByPK 'users' 3 "HAS_VISITED" 'cities' 20
  # SAN FRAN
  LUAFUNC addNodeRelationShipByPK 'users' 1 "HAS_VISITED" 'cities' 30
  LUAFUNC addNodeRelationShipByPK 'users' 2 "HAS_VISITED" 'cities' 30
  LUAFUNC addNodeRelationShipByPK 'users' 4 "HAS_VISITED" 'cities' 30

  # Users who have VISITed DC (using Pure Lua Function)
  SELECT lo.node.__name FROM users WHERE relindx() = 10

  # Unvisit DC for one user
  LUAFUNC deleteNodeRelationShipByPK 'users' 7 "HAS_VISITED" 'cities' 10

  # Users who have VISITed DC
  SELECT lo.node.__name FROM users WHERE relindx() = 10

  SELECT hometown, get_fof(lo) FROM users WHERE relindx() = 30
}}}


= MORE TO COME =
Tired again, I will write more tomorrow :)